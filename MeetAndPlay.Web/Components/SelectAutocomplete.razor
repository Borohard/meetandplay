@using MeetAndPlay.Core.Abstraction.Services
@using MeetAndPlay.Core.Infrastructure.Extensions
@using MeetAndPlay.Data.DTO
@using MeetAndPlay.Web.Infrastructure.Extensions
@using MeetAndPlay.Web.ViewModels
@using System.Reflection

<div class="dropdown">
    <button class="@ButtonClasses" type="button" id="@DropdownId"
            data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        @CurrentValue
    </button>
    <div class="@DropdownMenuClasses" aria-labelledby="@DropdownId" style="width: 300px;">
        <div class="form-group">
            <input type="text" class="form-control my-3" @bind=@Query  placeholder="Начните вводить..."/>
            @if (Options.Any())
            {
                <div class="list-group overflow-auto" style="height: 200px;">
                    @foreach (var option in Options)
                    {
                        <button type="button" @onclick="() => SetValue(option)" class="list-group-item list-group-item-action my-0 p-1">@option.Name</button>
                    }
                </div>
            }
            else
            {
                if (EnableDifferedLoad && Query.Length < MinSymbolsCountForDifferedLoad)
                {
                    <p>Необходимо ввести как минимум @MinSymbolsCountForDifferedLoad символа.</p>
                }
                else
                {
                    <p>Ничего не найдено :(</p>
                }
            }
        </div>
    </div>
</div>

@code {
    private string DropdownId => "dropdown-" + Guid.NewGuid();
    private string CurrentValue => Value.Name ?? Placeholder ?? "Начните вводить...";

    private const string ButtonClasses = "p-3 mx-4 btn btn-warning bg-lightyellow border-0 rounded-pill dropdown-toggle";
    protected const string DropdownMenuClasses = "dropdown-menu p-4 shadow border-0";
    
    [Parameter]
    public string Placeholder { get; set; }

    [Parameter]
    public NamedViewModel Value { get; set; }

    [Parameter]
    public IReadService Source { get; set; }

    [Parameter]
    public bool EnableDifferedLoad { get; set; }

    //TODO: Implement paging logic
    [Parameter]
    public bool EnablePaging { get; set; }

    [Parameter]
    public int PageSize { get; set; }
    
    [Parameter]
    public int MinSymbolsCountForDifferedLoad { get; set; }

    public string Query { get; set; }
    
    public NamedViewModel[] Options = {};

    public NamedViewModel[] LoadedOptions = {};

    protected override async Task OnInitializedAsync()
    {
        if (EnableDifferedLoad)
            return;
        
        var result = await Source.GetAllAsync();
        LoadedOptions = result.Items.ToViewModels();
        await UpdateOptionsAsync(true);
    }

    public async Task UpdateOptionsAsync(bool isFirstRender = false)
    {
        if (EnableDifferedLoad)
        {
            if (Query.Length < MinSymbolsCountForDifferedLoad)
                return;

            var result = await Source.GetResultsLikeAsync(new ReadFilterDto {Query = Query});
            Options = result.Items.ToViewModels();
        }
        else
        {
            var allOptions = LoadedOptions.AsEnumerable();
            if (!Query.IsNullOrWhiteSpace())
            {
                allOptions = allOptions.Where(o => o.Name.Contains(Query, StringComparison.InvariantCultureIgnoreCase));
            }
            Options = allOptions.ToArray();
        }
        if (!isFirstRender)
        {
            StateHasChanged();
        }
    }

    public void SetValue(NamedViewModel value)
    {
        Value = value;
        StateHasChanged();
    }

}